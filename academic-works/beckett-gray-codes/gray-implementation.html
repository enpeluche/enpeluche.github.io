<!DOCTYPE html>

<html lang="fr">
    <head>
        <!-- metadata -->

        <meta charset="UTF-8">
        <meta name="robots" content="index, follow">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <title>Implementation</title>

        <meta
            name="description"
            content=""
        >

        <meta
            name="keywords"
            content=""
        >
        
        <meta
            name="author"
            content="Lucas Petit"
        >

        <link rel="icon" href="/assets/img/logo/logo.ico" type="image/x-icon">
        
        <!-- for rendering latex -->

        <!-- CSS -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">

        <!-- JS -->
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

        <!-- ALL STYLESHEET -->
 
        <link rel="stylesheet" href="/assets/css/main.css">
    </head>
    <body>
        <header>
            <nav>
                <ul>
                    <li>
                        <a href="/academic-works/lattice-reduction/">
                            <svg class="ArrowBackwardIcon" style="fill:black;display: inline;" width="24" viewBox="0 0 24 24" transform="matrix(-1,0,0,1,0,0)"> <path d="m12 4-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z"></path> </svg>
                            Réduction de réseaux
                        </a>
                    </li>
                </ul>
            </nav>
        </header>
        
        <main>
            <div id="toc-container" style="height: 100vh;">
                <div id="min-toc"></div>
                <div id="full-toc" class="hidden"></div>
            </div>

            <div id="article">
                <h3>Implémentation</h3>

                <div class="paragraph">
                    Dans cette sous-section, on présente différentes implémentations d'algorithmes générant des codes de Beckett-Gray.
                    Les codes utilisés sont disponibles sur \href{https://github.com/Crowreed/GrayCodeCollection}{github}.
                </div>
    
                <h4>GC</h4>
    
                <div class="algorithm">
                    <h2>GC</h2>
                    
                    <div class="meta">
                        <div class="in"> $n \in \N$ </div>
                    </div>
                    
                    <div class="conditional">
                        <div class="if">
                            n=1:
                            <div class="c">
                                <div class="return">[0, 1]</div>
                            </div>
                        </div>
                    </div>
                    l=[0]*(2**n) <br>
                    
                    <div class="for">
                        i in range (2**(n-1)):
                        <div class="c">
                            l[i] = [0]+[GC(n-1)[i]]
                        </div>
                    </div>
    
                    <div class="for">
                        for i in range (2**(n-1), 2**n):
                        <div class="c">
                            l[i] = [1]+[list(reversed(GC(n-1)))[i-2**(n-1)]]
                        </div>
                    </div>
    
                    <div class="for">
                        for i in range (2**n):
                        <div class="c">
                            l[i] = flatten_list(l[i])
                        </div>
                    </div>
    
                    <div class="return">
                        l
                    </div>
    
    
    
    
                </div>
    
                <div class="paragraph">
                    Ce code est une implémentation de l'algorithme de génération de séquences de Gray réfléchie.
                </div>
                
                <div class="paragraph">
                    La fonction $GC(n)$ prend un entier $n$ comme argument et génère une séquence de Gray de longueur $2^n$,
                    sur des chaînes binaires de longueur $n$. La condition if $n==1$: renvoie $[0, 1]$, qui est la séquence
                    de Gray pour $n=1$. Ensuite, un tableau $l$ est initialisé avec des zéros, de longueur $2^n$. Deux boucles
                    for sont utilisées pour remplir la première moitié et la deuxième moitié du tableau $l$ avec des sous-listes
                    correspondant à la génération récursive des séquences de Gray pour $n-1$. La fonction flatten\_list est utilisée
                    pour aplatir les sous-listes. La séquence résultante est renvoyée. La récursivité de cet algorithme entraîne une
                    utilisation importante de la mémoire pour de grandes valeurs de $n$.
                </div>
    
                <h4>GCParity</h4>
    
                <div class="algorithm">
                    <h2>GCParity</h2>
    
                    <div class="meta">
                        <div class="in">n</div>
                    </div>
    
                    l = [[0]*n] <br>
                    <div class="for">
                        i in range(1,2**n):
                        <div class="c">
                            <div class="conditional">
                                <div class="if">
                                    if (i%2)==1:
                                    <div class="c">
                                        l.append(l[-1].copy())
                                        l[-1][-1]=l[-1][-1]^1            
                                    </div>
                                </div>
                                <div class="else">
                                    <div class="c">
                                        <div class="for">
                                            for k in range(n-1,-1,-1):
                                            <div class="c">
                                                <div class="conditional">
                                                    <div class="if">
                                                        if l[-1][k]==1:
                                                        <div class="c">
                                                            l.append(l[-1].copy()) <br>
                                                            l[-1][k-1]=l[-1][k-1]^1 <br>
                                                            break
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
    
                    <div class="return">l</div>
            
    
                </div>
                
                <div class="paragraph">
                    C'est une autre façon de générer une séquence de Gray. Cela fonctionne en regardant la parité de l'indice de
                    la ligne du code que l'on génère. Si cette ligne est impaire, il suffit juste d'inverser le dernier bit de
                    la ligne précédente, ici réalisé avec un XOR entre ce bit et $1$. Si cette ligne est paire, on inverse le
                    bit juste à gauche du bit à $1$ le plus à droite.
                </div>
    
                <h4>GCmod</h4>
    
                <div class="algorithm">
                    <h2>GCmod</h2>
                    <div class="meta">
                        <div class="in">n</div>
                    </div>
                    l = [[0]*n for i in range(2**n)] <br>
                    <div class="for">
                        for i in range(2**n):
    
                        <div class="for">
                            for j in range(n):
                                if (i+2**j+2**(j+1))%(2**(j+2)) < 2**(j+1):
                                    l[i][n-j-1] = 1
                        </div>
                    </div>
    
                    <div class="return">l</div>
                </div>
    
                <div class="paragraph">
                    Une dernière façon de générer une séquence de Gray. On cherche à trouver où rajouter les $1$ dans la séquence en utilisant le fait que les bits à la position $j$ sont changés tous les $2^{j+1}$ itérations.\\
                </div>
                
                <figure>
                    <div class="fig-container">
                        <img src="/assets/img/academic-projects/beckett-gray-codes/gray-codes/gray-implementation/exemple.png" alt="">
                    </div>
    
                    <figcaption>Représentation graphique d'un code de Gray $n=5$</figcaption>
                </figure>
    
                <div class="paragraph">
                    On peut l'observer sur cette représentation graphique un code de Gray pour $n=5$, où les bits au centre changent toutes les
                    deux itération, puis ceux à côté en allant vers l'extérieur toutes les quatre itérations, puis toutes les huit itérations etc.
                </div>
            </div>

        </main>

        <footer id="main-footer"></footer>
        
        <script type="module" src="/assets/js/main.js"></script>
    </body>
</html>