<!DOCTYPE html>

<html lang="fr">
    <head>
        <!-- metadata -->

        <meta charset="UTF-8">
        <meta name="robots" content="index, follow">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        
        <title>Vers une réduction LLL adaptée aux réseaux d’approximation</title>

        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta charset="UTF-8">
        <meta name="author" content="Lucas Petit">
        <meta name="description" content="Dans ce cours, vous apprendrez les bases de la théorie des réseaux euclidiens utilisés en cryptographie. Prêt pour l'aventure ?">
        <meta name="keywords" content="Réseaux Euclidiens, Cryptographie">

        <link rel="stylesheet" href="/assets/css/base/root.css">
        <link rel="stylesheet" href="/assets/css/base/base.css">
        <link rel="stylesheet" href="/assets/css/base/inter.css">
        <link rel="stylesheet" href="/assets/css/base/reset.css">
        <link rel="stylesheet" href="/assets/css/base/utils.css">

        <link rel="stylesheet" href="/assets/css/layout/header.css">
        <link rel="stylesheet" href="/assets/css/layout/toc.css">

        <link rel="stylesheet" href="/assets/css/academic-works.css">
        <link rel="stylesheet" href="/assets/css/article.css">
        <link rel="stylesheet" href="/assets/css/homepage.css">
        <link rel="stylesheet" href="/assets/css/project.css">
        
        <link rel="stylesheet" href="/assets/css/figure.css">
        <link rel="stylesheet" href="/assets/css/footer.css">
        <link rel="stylesheet" href="/assets/css/icon.css">
        <link rel="stylesheet" href="/assets/css/references.css">
        <link rel="stylesheet" href="/assets/css/footnotes.css">
        <link rel="stylesheet" href="/assets/css/algorithm.css">

        <link rel="icon" href="/assets/img/logo/logo.ico" type="image/x-icon">

        <!-- for rendering latex -->

        <!-- CSS -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
        
        <!-- JS -->
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
        <script defer src="/assets/js/katex-config.js"></script>
    </head>
    <body>
        <header>
            <nav>
                <ul>
                    <li>
                        <a href="/academic-works/lattice-reduction/">
                            <svg class="ArrowBackwardIcon" style="fill:black;display: inline;" width="24" viewBox="0 0 24 24" transform="matrix(-1,0,0,1,0,0)"> <path d="m12 4-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z"></path> </svg>
                            Réduction de réseaux
                        </a>
                    </li>
                </ul>
            </nav>
        </header>
        
        <main>
            <div class="huhu hidden">
                <div>
                    <button id="eee">
                        <svg class="" viewBox="0 0 24 24" fill="black">
                            <path d="M19 5v14H5V5zm1.1-2H3.9c-.5 0-.9.4-.9.9v16.2c0 .4.4.9.9.9h16.2c.4 0 .9-.5.9-.9V3.9c0-.5-.5-.9-.9-.9M11 7h6v2h-6zm0 4h6v2h-6zm0 4h6v2h-6zM7 7h2v2H7zm0 4h2v2H7zm0 4h2v2H7z"></path>
                        </svg>
                    </button>
                </div>
            </div>
            <div id="toc"></div>

            <div id="article">
                <h2>Vers une réduction LLL adaptée aux réseaux d’approximation</h2>

                <div class="paragraph">
                    On va donner une définition équivalente du réseau d'approximation \( (F, \sigma) \) mais adaptée pour les réseaux euclidiens.
                </div>

                <div class="definition">
                    Soit \( F \in M_n (\Z) \), un degré de précision \( \sigma \in \N\), et \(p \in \N\). On définit
                    \[
                    F_{p^\sigma} \coloneqq  \{ v \in \Z^n | vF = 0 \mod p^\sigma \}
                    \]
                </div>
                
                <div class="paragraph">
                    Contrairement au cas polynomial, la situation est ici fondamentalement différente.
                    Nous verrons par la suite s’il est nécessaire d’imposer des restrictions sur \( p \) et \( \sigma \),
                    et le cas échéant, lesquelles.
                </div>

                <div class="proposition">
                    \( F_{p^\sigma} \) est un réseau euclidien de dimension \( n \).
                </div>

                <div class="remark">
                    \( F_{p^\sigma} \) est un réseau \( p^\sigma\)-aire.
                </div>

                <div class="paragraph">
                    Comment peut-on calculer une base de \( F_{p^\sigma} \) ?
                    Est-il possible d’en extraire une base \( \mathrm{LLL} \)-réduite, et ce, de manière efficace ?
                    Comme dans le cas polynomial traité pour le réseau \( (F, \sigma) \), il est d'abord nécessaire
                    de calculer une décomposition de la forme
                    
                    $$
                    \begin{equation}
                        \underbrace{
                            \begin{bmatrix}
                                e_{\tau(1)} \\
                                \vdots \\
                                e_{\tau(n)}
                            \end{bmatrix}
                        }_{P}
\cdot
\underbrace{
    \begin{bmatrix}
        L_r & 0 \\
        G & I_{m-r}
    \end{bmatrix}
}_{L}
\cdot
F
=
\underbrace{
    \begin{bmatrix}
        E'\\
        0
    \end{bmatrix}
}_{E}
\end{equation}
$$
où \(r \coloneqq \rang(F) \), \( P \) est une matrice de permutation, \( L \) est une matrice triangulaire inférieure et \( E \) est échelonnée en ligne.


                </div>

                <details>
                    <summary></summary>

                    <p>
Il s’agit d’une généralisation de la décomposition \( P L F = U \),
                        où \( U \) était une matrice triangulaire supérieure. Ici, on relâche cette contrainte en ne demandant
                        que \( U \) soit échelonnée par lignes.}
                    </p>
                </details>

                <div class="algorithm">
                    <h2>\textsc{PLE}$(A)$</h2>
                    <div class="meta">
                        <div class="in">\KwIn{$A \in \mathbb{K}^{n \times m}$}</div>
                        <div class="out">\KwOut{Matrices \( P \), \( L \), \( E \) telles que \( 6.1 \) est satisfaite.}</div>
                    </div>

    
    
    
    $n \gets \text{nrows}(A)$,\quad $m \gets \text{ncols}(A)$\;
    $P \gets I_n$, \quad $L \gets I_n$, \quad $E \gets A$\;
    
    \Pour{$i \gets 0$ \KwTo $m{-}1$}{
        $(\text{pivot}, i_{\text{pivot}}) \gets \textsc{Pivot}(E_{*,i}, \{i, \dots, n{-}1\})$\;
        
        \Si{$\text{pivot} = \texttt{None}$}{
            \textbf{continuer}
        }
        
        \Si{$i_{\text{pivot}} \neq i$}{
            Échanger les lignes $i$ et $i_{\text{pivot}}$ dans $P$ et $E$\;
            
            \Pour{$k \gets 0$ \KwTo $i{-}1$}{
                Échanger $L[i,k]$ et $L[i_{\text{pivot}},k]$\;
            }
        }
        
        \Pour{$j \gets i{+}1$ \KwTo $n{-}1$}{
            $s \gets E[j,i] / \text{pivot}$\;
            \Si{$s \neq 0$}{
                $E \gets E$ avec ligne $j$ \textbf{moins} $s$ fois ligne $i$\;
                $L \gets L$ avec ligne $j$ \textbf{moins} $s$ fois ligne $i$\;
            }
        }
    }
    
                    <div class="return">$(P, L, E)$</div>
                </div>

                <div class="remark">
                    Comme c'est vrai pour toute permutations, il serait intéressant de choisir certaines permutations particulières,
                    notamment qui ordonne les vecteurs par norme croissante.
                </div>

                <div class="remark">
                    J'ai mis trop d'investissement dans cet algorithme, j'en ai fais plusieurs versions, allant d'une version naïve
                    où je calculais tous les pivots pour ordonner les lignes de façon à avoir les mineurs principaux inversibles,
                    à une stratégie plus subtile d'échange quand nécessaire, grâce aux conseils avisés de mon encadrant. Cet algorithme
                    fonctionne sur \( \Z_p \) pour \( p \) premier, car les pivots sont inversibles, je réfléchissais à une stratégie
                    pour rendre cet algorithme fonctionnel  sur \( \Z_n \).
                </div>

                <div class="theorem">
                    L'algorithme PLE calcule correctement une décomposition qui satisfait 6.1.
                </div>

                <div class="counterexample">
                    <span class="title">Limite de l’algorithme PLE</span> <br>
                    
                    L’algorithme PLE ne s’applique pas dans tous les cas. 
    
                    Soit
                    
                    \[
                    A =
                    \begin{bmatrix}
                        3 & 4 \\
                        4 & 3
                    \end{bmatrix}
                    \in M_2(\mathbb{Z}/12\mathbb{Z}).
                    \]

                    Dans cet anneau, les coefficients \( 3 \) et \( 4 \) ne sont pas inversibles, ce qui empêche de procéder aux opérations
                    de pivot nécessaires. <br>
    
                    Ce contre-exemple montre que la validité de l’algorithme repose sur une hypothèse cruciale :
                    <strong>les pivots doivent être inversibles</strong>. 
                </div>
                
                <div class="example">
                    \[
                    \displaystyle
                    \underbrace{
                        \begin{pmatrix}
                            1 & 0 & 0 & 0 \\
                            -\frac{3}{4} & 1 & 0 & 0 \\
                            -\frac{1}{2} & 0 & 1 & 0 \\
                            0 & -\frac{1}{3} & 0 & 1
                        \end{pmatrix}
                    }_{L}
                    \times
                    \underbrace{
                        \begin{pmatrix}
                            1 & 0 & 0 & 0 \\
                            0 & 0 & 1 & 0 \\
                            0 & 1 & 0 & 0 \\
                            0 & 0 & 0 & 1
                        \end{pmatrix}
                    }_{P}
                    \underbrace{
                        \begin{pmatrix}
                            4 & 2 & 4 & 2 \\
                            2 & 1 & 2 & 1 \\
                            3 & 3 & 3 & 3 \\
                            1 & 1 & 1 & 1
                        \end{pmatrix}
                    }_{F}
                    =
                    \underbrace{
                        \begin{pmatrix}
                            4 & 2 & 4 & 2 \\
                            0 & \frac{3}{2} & 0 & \frac{3}{2} \\
                            0 & 0 & 0 & 0 \\
                            0 & 0 & 0 & 0
                        \end{pmatrix}
                    }_{E}
                    \]
                </div>
                
                <div class="paragraph">
                    On en déduit donc un algorithme pour calculer une base.

                    De 6.1 on déduit que 

                    \[
                    \begin{bmatrix}
                        e_{\tau(1)} \\
                        \vdots \\
                        e_{\tau(n)}
                    \end{bmatrix}
                    \cdot
                    \begin{bmatrix}
                        L_r \cdot p^\sigma & 0 \\
                        G & I_{m-r}
                    \end{bmatrix}
                    \cdot
                    F
                    =
                    \begin{bmatrix}
                        E' \cdot p^\sigma\\
                        0
                    \end{bmatrix}
                    =
                    \begin{bmatrix}
                        0\\
                        0
                    \end{bmatrix}
                    \mod p^\sigma
                    \]
                </div>

                <div class="theorem">

\begin{theoreme}
    Les matrices
    \[
    \begin{bmatrix}
        L_r \cdot p^\sigma & 0 \\
        G & I_{m-r}
    \end{bmatrix}
    \cdot
    \begin{bmatrix}
        e_{\tau(1)} \\
        \vdots \\
        e_{\tau(n)}
    \end{bmatrix}
    , \quad
    \begin{bmatrix}
        I_r \cdot p^\sigma & 0 \\
        G & I_{m-r}
    \end{bmatrix}
    \cdot
    \begin{bmatrix}
        e_{\tau(1)} \\
        \vdots \\
        e_{\tau(n)}
    \end{bmatrix}
    \]
    sont deux bases de \( F_{p^\sigma}\)
\end{theoreme}
                </div>

                <div class="remark">
                    Il vaut mieux privilégier la seconde base car les \(r\) premières lignes sont orthonormées, ce qui nous
                    permet de déduire intuitivement que la base sera de meilleure qualité.
                </div>

                <!--%CA MARCHE QUE QUAND SIGMA VAUT 1-->

                <div class="algorithm">
                    <h2>Basis$(F, p, \texttt{mode})$</h2>

                    <div class="meta">
                        <div class="in"> Une matrice \( F \in \mathbb{K}[x]^{m \times n} \), un scalaire \( p \in \mathbb{K} \), et une chaîne mode égale à v1 ou v2</div>
                        <div class="out"> Une base transformée selon le mode choisi</div>
                    </div>
    
                    $G \gets \text{copie}(F)$<br>
                    $(P, L, E) \gets \textsc{PLE}(G)$ <br>
                    $r \gets \text{rang}(F)$ <br>
    
                    <div class="conditional">
                        <div class="if">
                            mode = v1
                            <div class="c">
                                <div class="for">
                                    $i \gets 0$ \KwTo $r{-}1$
                                    <div class="c">
                                        Multiplier la ligne $i$ de $L$ par $p$
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="conditional">
                        <div class="if">
                            mode = v2
                            <div class="c">
                                <div class="for">
                                    $i \gets 0$ \KwTo $r{-}1$
                                    <div class="c">
                                        Remplacer la ligne $i$ de $L$ par $p \cdot e_i$\;
                                        \tcp*{$e_i$ : $i$-ème vecteur de la base canonique}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
      
                    <div class="return">$L \cdot P$</div>
                </div>

                <div class="example">
                    En partant de la matrice 
                    \(
                    F = 
                    \begin{pmatrix}
                        4 & 2 & 4 & 2 \\
                        2 & 1 & 2 & 1 \\
                        3 & 3 & 3 & 3 \\
                        1 & 1 & 1 & 1
                    \end{pmatrix}
                    \)
    
                    On peut calculer une base de \( F_{5^4}\)
    
                    \[
                    \begin{pmatrix}
                        625 & 0 & 0 & 0 \\
                        -\frac{1}{2} & 1 & 0 & 0 \\
                        0 & 0 & 625 & 0 \\
                        0 & 0 & -\frac{1}{3} & 1
                    \end{pmatrix}
                    \]
                </div>
                
                <div class="paragraph">
                    On peut donc maintenant définir un algorithme sur un principe diviser pour régner.
                </div>
  
                <div class="algorithm">
                    <h2>LLL-DAC-Padique$(F, p, \sigma)$</h2>

                    <div class="meta">
                        <div class="in"> $F \in \mathbb{K}^{m \times n}$, un entier premier $p$, un entier $\sigma \geq 1$</div>
                        <div class="out"> Une base "LLL-réduite?" en précision $p^\sigma$</div>
                    </div>
    
    
                    <div class="conditional">
                        <div class="if">
                            $\sigma = 1$
                            <div class="c">
                                <div class="return"> $LLL(ApproximantBasis(F, p))$</div>
                            </div>
                        </div>
                    </div>
    
    
    $\tau \gets \left\lfloor \dfrac{\sigma + 1}{2} \right\rfloor$\;
    
    $V_1 \gets \textsc{LLL-DAC-Padique}(F, p, \tau)$ \tcp*[r]{Appel récursif sur demi-précision}
    
    $F_{\text{low}} \gets \dfrac{V_1 \cdot F}{p^\tau}$ \tcp*[r]{Mise à jour du problème}
    
    $V_2 \gets \textsc{LLL-DAC-Padique}(F_{\text{low}}, p, \sigma - \tau)$ \tcp*[r]{Appel récursif décalé}

                    <div class="return">$V_2 \cdot V_1$</div>
                </div>

                <div class="paragraph">
                    Similairement à la preuve du chapitre précédent, \(V_2 V_1\) est une base de \( F_{p^\sigma} \).
                </div>

                <div class="problem">
                    <span class="title"> <strong> (Question)</strong></span> <br>
                    Dans quelle mesure le produit de matrices LLL-réduites reste-t-il lui-même LLL-réduit ?
                    Peut-on quantifier cette propriété ?
                </div>

                <div class="paragraph">
                    Si \( V_1 \) est une matrice orthogonale, c'est-à-dire dont les lignes sont orthonormées,
                    alors \( V_2 V_1\) est \( \mathrm{LLL}\)-réduite.

                    On rappelle que \( V_1 = U_1 V_1^* \) d'après le procédé de Gram-Schmidt. <br>
                    <span class="nowrap">En écrivant \( V_1 V_2 = V_1 V_2^* ((V_2^*)^{-1} U_2 V_2^*) \), peut-être pourront nous mieux contrôler
                    le résultat du produit.</span>
                </div>
            </div>

        </main>

        <footer id="main-footer"></footer>

        <script src="/assets/js/components/algorithm.js"></script>
        
        <script src="/assets/js/components/footer.js"></script>
        <script src="/assets/js/components/header.js"></script>
        <script src="/assets/js/components/article.js"></script>
        <script src="/assets/js/components/toc.js"></script>
        <script src="/assets/js/components/references.js"></script>
    </body>
</html>